



# Markadan – “Yemek Tarifi” Uygulama Adımları (v4 – Tasarımdan Entity’lere, Hikâyeli Reçete)

> **Tema:** Bir restoran açıyoruz. Önce konsepti (tasarım) kuruyor, sonra menüyü (DTO’lar) yazıyor, malzeme deposunu (entity’ler + veritabanı) düzenliyor, aşçılara (servisler) tarif veriyor, garsonlara (controller) replik öğretiyoruz. Her adımda “**böyle yaparız, çünkü…**”

---

## 0) Konseptin Çizimi (Tasarım & Mimari)

**Neyi kuruyoruz?**: E‑shopping ‘Markadan’ – katalog → sepet → sipariş.

**Mimari konsept:** Onion.

* **Salon (API)**: müşterinin oturduğu alan. Garson (controller) yalnızca sipariş alır ve iletir.
* **Mutfak dili (Application)**: “Nasıl pişirileceği” değil, **ne istendiği** (port/sözleşme).
* **Mutfak (Infrastructure)**: EF Core ile gerçek pişirme; veri hazırlama.
* **Kiler (Domain/Entities)**: malzemeler (entity’ler) ve ilişkiler.

**Neden Onion?** Çünkü **yüksek seviye** (API) **düşük seviyeyi** (EF/SQL) bilmemeli. Bilirse menü (UI) değiştiğinde mutfak (veritabanı) akışın içine düşer. Bağımlılığı **soyuta** ters çeviririz; test ederken “sahte aşçı” (mock) takabiliriz.

**Tasarım prensipleri (iş kuralı diyeti):**

* **no\_public\_stock**: Stok müşteriye görünmez. *Çünkü stok rakamı manipülatif olabilir, güvenlik ve UX politikasıdır.*
* **Fiyat yalnız sayı**: “₺”’yi garson ekler. *Çünkü formatlama sunum katmanının işidir.*
* **DTO = sözleşme**: Dışarı yalnız DTO çıkar. *Çünkü entity’ler sırrımızdır; içeride değiştiririz, dışarı kırmayız.*
* **Query = Servis, Command = İnce Repo**: *Çünkü okuma performans ister (projeksiyon), yazma ise tutarlılık (UoW) ister.*

---

## 1) Depoyu Kur (Entity’ler – Domain Model)

> **Analojimiz:** Kiler raflarını diziyoruz. Her kavanozun etiketi (tablo), gramı (tip), komşusu (ilişki) belli.

**AppUser (IdentityUser<int> genişletilmiş)**

* *Neden int key?* SQL Server’da sık ve hızlı; Guid ile de olur ama indeksler daha ağır olur.
* Ek alanlar: `Name, Surname, GovId, Birthday, IsDeleted`
* *Soft delete mi?* Kullanıcıda evet (`IsDeleted`). *Çünkü yasal ve raporlama ihtiyacı olabilir.*

**Brand**

* `Id, Name, Description?, ImageUrl?`
* İlişki: **1→N** Product.
* *Neden ayrı tablo?* Filtreleme/sayfalama/marka sayfaları için.

**Category**

* Benzer yapı; **1→N** Product.
* *Neden ayrı?* Navigasyon ve SEO/filtre akışı için.

**Product**

* `Id, Title, Price:decimal(18,2), Stock:int, ImageUrl?, Description?, BrandId, CategoryId`
* *Neden decimal?* Fiyat double ile kayan sayı hatasına düşer.
* *Neden FK zorunlu?* Katalog bütünlüğü; brandsız/kategorisiz ürün olmaz.

**Cart & CartItem**

* `Cart` → `Id, AppUserId, Status (Active/Ordered), CreatedAtUtc, UpdatedAt?`
* `CartItem` → `ProductId, Quantity, UnitPriceSnapshot, TitleSnapshot, ImageUrlSnapshot`
* *Neden snapshot?* Sipariş anında fiyat/değer kilitlenir; ürün sonra değişse de fatura tutarlıdır.

**Address**

* Kullanıcıya bağlı teslimat/fatura adresleri.

> **Böyle yaparız, çünkü…** İlişkiler net ve tek yönlü: **Product** merkez, **Brand/Category** referans, **CartItem** siparişin geçmişe kilidi. Sonradan raporlama ve uyumluluk kolaylaşır.

---

## 2) Menü Kartını Bas (DTO’lar – API Sözleşmesi)

**ProductListDTO** → `Id, Title, Price, ImageUrl?, BrandId, BrandName, CategoryId, CategoryName`
**ProductDetailDTO** → Liste + `Description?`
**PagedResult<T>** → `Total, Page, PageSize, Items`

*Böyle yaparız, çünkü…* Liste tabağı **hafif** olmalı; müşteri sayfayı çevirirken hızlı görsün. Detay tabağı **doyurucu**; açıklama sosu orada.

> **Kural:** DTO **positional record** ise yapıcı **sırasına** saygı. EF’nin `Select` ifadesi **named argument** kabul etmez.

---

## 3) Sos Kitabı (AutoMapper – opsiyonel)

Application’da `CatalogProfile` tutarız.
*Böyle yaparız, çünkü…* Yazma akışında (Admin CRUD) entity↔DTO dönüşleri merkezî olur. Okumada zaten LINQ ile **direkt projeksiyon** yapacağız; performans için bu yeterli.

> **Not:** `AutoMapper.Extensions.Microsoft.DependencyInjection` artık tarih; ana paketle `AddAutoMapper(cfg => cfg.AddMaps(typeof(CatalogProfile).Assembly))` yeter.

---

## 4) Garsonun Mutfağa Cümlesi (Application Port)

`IProductReadService` tanımlarız:

* `GetDetailAsync(int id)`
* `ListAsync(categoryId, brandId, q, min, max, sort, page, pageSize)`

*Böyle yaparız, çünkü…* Garson (controller) **ne** istediğini söyler; **nasıl** pişeceğini bilmez. Testte sahte aşçı takabiliriz (mock/fake). Değiştirilebilirlik.

---

## 5) Aşçı Ocağa (Infrastructure Service – Read)

**ProductReadService** (sealed) – kural: **DbContext içeride, dışarıda değil.**

* **AsNoTracking()**: *Okuyoruz; fiş kesmiyoruz. Bellek/CPU korur.*
* **Select → DTO**: *Sadece gereken kolonlar. `Include` ile kazanı doldurmuyoruz; EF JOIN çıkarır.*
* **Detail**: `Where(Id)` + `Select(DetailDTO)` + `SingleOrDefaultAsync`
  *Böyle yaparız, çünkü…* Aynı Id’den iki kayıt çıkarsa bu veri bozulmasıdır; tek kayıt bekleriz.
* **List**: **filtre** → **sort** → **Count** → **Select(ListDTO)** + `Skip/Take`
  *Böyle yaparız, çünkü…* `Count`’u önce alırız; aksi halde toplam sayfa yanlışlanır. Paging’i veritabanı yapar; ağdan yalnız bu sayfa gelir.

> **Hata Avcısı**: “An expression tree may not contain a named argument specification” görürsen, `new Dto(...)`’yu **pozisyonel** sırayla yaz. Tip uyuşmazlığı (CS1503) görürsen DTO yapıcı **sırasını** kontrol et.

---

## 6) Mutfak Kayıtları (Dependency Injection – Infrastructure)

`AddInfrastructure(config)` içinde:

* `AddDbContext<MarkadanDbContext>(...)` (retry policy)
* `AddScoped<IProductReadService, ProductReadService>()` (**tek** kayıt)

*Böyle yaparız, çünkü…* API implementasyon tipini bilmesin; bir gün Worker host’a geçtiğimizde de aynı mutfağı tek satırla takarız.

---

## 7) Salon Kurulumu (Program.cs)

* `builder.Services.AddInfrastructure(Configuration);`
* (Opsiyonel) `AddAutoMapper(...)`
* Swagger (dev), HTTPS, `MapControllers()`
* (Dev) migrate — Prod’da CI/CD adımıyla yönet.

*Böyle yaparız, çünkü…* Kompozisyon kökü sade kalır; tüm kayıtlar modüllerin kendi mutfağında.

---

## 8) Garsonun Repliği (İnce Controller)

`ProductsController`

* **Liste**: Query paramlarını al → `IProductReadService.ListAsync(...)` → **aynen** döndür (`PagedResult<ProductListDTO>`).
* **Detay**: `GetDetailAsync(id)` → yoksa `NotFound()` (ASP.NET Core **ProblemDetails** ile döner: `type/title/status/traceId`).

*Böyle yaparız, çünkü…* Garson konuşmayı bilir, pişirmez. İş mantığı mutfakta; controller test edilebilir, değişimler ucuz.

---

## 9) Ön Yüzle El Sıkışma

* UI, `?categoryId=&brandId=&q=&min=&max=&sort=&page=&pageSize=` paramlarını üretir.
* API yalnız **sayı** fiyat döner; UI `₺` ile süsler.
* Stok **hiçbir public DTO’da** yoktur.
  *Böyle yaparız, çünkü…* Sözleşme nettir; web, mobil, admin aynı API’yi kullanır; kural tek yerde uygulanır.

---

## 10) Yazma Günü Geldiğinde (Hibrit – Command)

* **Query = Servis** (şimdi kurduk), **Command = İnce Repo (+UoW)** (Admin CRUD’da gelir).
* `IBaseRepository<T>` yalnız: `Add, Update, DeleteById, GetByIdForUpdate, Exists`.
* Read’i repo’ya **koymayız**.
  *Böyle yaparız, çünkü…* Yazma tutarlılığı (SaveChanges/Transaction) repo/UoW ile, okuma performansı **projeksiyonla** sağlanır.

---

## 11) Tadım Listesi (Checklist)

* [ ] Controller’da **DbContext sorgusu yok**; servis çağrısı var.
* [ ] Serviste **AsNoTracking** + **Select→DTO** (positional).
* [ ] `Stock` sızmıyor; fiyat sayısal.
* [ ] DI kayıtları tek yerde (Infrastructure).
* [ ] Swagger: boş id (UI uyarısı), var id (200), yok id (404 ProblemDetails).
* [ ] SQL log: yalnız DTO kolonları.

---

## 12) Sık Düşülen Çukurlar → Kısa Köprüler

* **Named args**’ı expression’da kullanma → pozisyonel ctor.
* **DTO sırası** şaşarsa CS1503 patlar → imzaya bak, sırayı düzelt.
* **Include şişirmesi** → `Select→DTO` kullan; ağ + bellek rahatlar.
* **Çift DI kaydı** → yineleneni sil; son kayıt kazanır.
* **404 gövdesi nereden geldi?** `[ApiController]` varsayılan **ProblemDetails** üretir; istersen özelleştirilir.

---

## 13) Kapanış Mantraları

* **Garson controller, aşçı servis; menü DTO, kiler DbContext.**
* **Query serviste, command repoda — hepsi scoped, hepsi ölçülü.**
* **`Select→DTO` performans + güvenlik + kontrat istikrarı; `Include` ile kazan taşırma.**

> *“Müşteriye temiz menü sun; pişirmeyi mutfakta yap; kileri düzenli tut. Böyle kurulan bir mutfak, yoğun saatte bile serinkanlı kalır.”*




